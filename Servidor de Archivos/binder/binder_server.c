/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */


#include "binder.h"
#include <unistd.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include  <stdio.h>
#include <string.h>

#define COMISIONES 6
#define init pthread_mutex_init     /* Macro para la función pthread_mutex_init */
#define lock pthread_mutex_lock     /* Macro para la función pthread_mutex_lock */
#define unlock pthread_mutex_unlock /* Macro para la función pthread_mutex_unlock */



int cantIps=0;
//Tabla de archivos con la ultima version
archivoVersion* arch;
int cantArch=0;
char* ips[COMISIONES];
pthread_mutex_t versiones;

void *
registrarse_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	
	if (cantIps<COMISIONES)
	{
	  ips[cantIps]=malloc(strlen(*argp));
	  strcat(ips[cantIps],*argp);
	  cantIps++;
	}

	return (void *) &result;
}

char **
getipregistradas_1_svc(void *argp, struct svc_req *rqstp)
{
  
	
	int i;
	static char * result;
	char* aux;
	aux=(char *)malloc(96);;
	for (i=0;i<cantIps;i++)
	{
	  strcat(aux,ips[i]);
	  strcat(aux,"\n");
	}
	result =aux;
	return &result;
}

void *
eliminarip_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;

	int i,j;
	int encontre;
	i=0;
	encontre=0;
	while (i<cantIps && !encontre)
	{
	  if (!strcmp(ips[i],*argp))
	  {
	    encontre=1;
	    free(ips[i]);
	    cantIps--;
	  }
	  else
	    i++;
	}
	if (encontre==1)
	    for (j=i;j<COMISIONES;j++)
		ips[j]=ips[j+1];

	return (void *) &result;
}

char **
update_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;
	char* aux;
	int i=0;
	char c;
	//el +2 es para reservar para el espacio y \n. El +1 reserva espacio para \0 al final de la tabla
	aux=(char * )malloc((cantArch* (sizeof(archivoVersion)+2))+1);
	*aux='\0';
	while (i<cantArch){
	  strcat(aux,(arch+i)->archivo);
	  strcat(aux," ");
	  c=(char)((arch+i)->v+'0');
	  strcat(aux,&c);
	  c='\n';
	  strcat(aux,&c);
	  i++;
	}
	c='\n';
	strcat(aux,&c);
	result=aux;
	return &result;
}

int *
getversionaescribir_1_svc(char **argp, struct svc_req *rqstp)
{
	static int  result;
	int i;
	int encontre;
	if (cantArch==0)
	  arch=(archivoVersion*)malloc(100* sizeof(archivoVersion));
	else
	  if (cantArch%100==0)
	    arch=(archivoVersion*)realloc (arch,(cantArch+100)*sizeof(archivoVersion));
	i=0;
	encontre=0;
	while (i<cantArch && !encontre)
	{
	  if (strcmp((arch+i)->archivo,*argp)==0)
	  {
	    encontre=1;
	    //lock (&versiones);
	    ((arch+i)->v)++;
	    result=(arch+i)->v;
	    //unlock (&versiones);
	  }
	  i++;
	}
	if (encontre==0)
	{
	  result=0;
	  (arch+cantArch)->archivo=(char*)malloc(100);
	  *((arch+cantArch)->archivo)='\0';
	  strcat(((arch+cantArch)->archivo),*argp);
	  //lock (&versiones);
	  (arch+cantArch)->v=0;
	  cantArch++;
	  //unlock (&versiones);
	}
	return &result;
}
